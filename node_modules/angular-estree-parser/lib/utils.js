"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = require("@angular/compiler");
const ng = require("@angular/compiler/src/expression_parser/ast");
const lexer_1 = require("@angular/compiler/src/expression_parser/lexer");
const parser_1 = require("@angular/compiler/src/expression_parser/parser");
const NG_PARSE_FAKE_LOCATION = 'angular-estree-parser';
const NG_PARSE_TEMPLATE_BINDINGS_FAKE_PREFIX = 'NgEstreeParser';
const NG_PARSE_FAKE_ABSOLUTE_OFFSET = 0;
/* istanbul ignore next */
const NG_PARSE_SHARED_PARAMS = /^(?:[67]|8\.[01])\./.test(compiler_1.VERSION.full)
    ? [NG_PARSE_FAKE_LOCATION]
    : [NG_PARSE_FAKE_LOCATION, NG_PARSE_FAKE_ABSOLUTE_OFFSET];
function createNgParser() {
    return new parser_1.Parser(new lexer_1.Lexer());
}
function parseNg(input, parse) {
    const ngParser = createNgParser();
    const { astInput, comments } = extractComments(input, ngParser);
    const { ast, errors } = parse(astInput, ngParser);
    assertAstErrors(errors);
    return { ast, comments };
}
function parseNgBinding(input) {
    return parseNg(input, (astInput, ngParser) => ngParser.parseBinding(astInput, ...NG_PARSE_SHARED_PARAMS));
}
exports.parseNgBinding = parseNgBinding;
function parseNgSimpleBinding(input) {
    return parseNg(input, (astInput, ngParser) => ngParser.parseSimpleBinding(astInput, ...NG_PARSE_SHARED_PARAMS));
}
exports.parseNgSimpleBinding = parseNgSimpleBinding;
function parseNgAction(input) {
    return parseNg(input, (astInput, ngParser) => ngParser.parseAction(astInput, ...NG_PARSE_SHARED_PARAMS));
}
exports.parseNgAction = parseNgAction;
function parseNgTemplateBindings(input) {
    const ngParser = createNgParser();
    const { templateBindings: ast, errors } = ngParser.parseTemplateBindings(NG_PARSE_TEMPLATE_BINDINGS_FAKE_PREFIX, input, ...NG_PARSE_SHARED_PARAMS);
    assertAstErrors(errors);
    return ast;
}
exports.parseNgTemplateBindings = parseNgTemplateBindings;
function parseNgInterpolation(input) {
    const ngParser = createNgParser();
    const { astInput, comments } = extractComments(input, ngParser);
    const prefix = '{{';
    const suffix = '}}';
    const { ast: rawAst, errors } = ngParser.parseInterpolation(prefix + astInput + suffix, ...NG_PARSE_SHARED_PARAMS);
    assertAstErrors(errors);
    const ast = rawAst.expressions[0];
    visitSpan(ast, span => {
        span.start -= prefix.length;
        span.end -= prefix.length;
    });
    return { ast, comments };
}
exports.parseNgInterpolation = parseNgInterpolation;
function visitSpan(ast, fn) {
    if (!ast || typeof ast !== 'object') {
        return;
    }
    if (Array.isArray(ast)) {
        return ast.forEach(value => visitSpan(value, fn));
    }
    for (const key of Object.keys(ast)) {
        const value = ast[key];
        if (key === 'span') {
            fn(value);
        }
        else {
            visitSpan(value, fn);
        }
    }
}
function assertAstErrors(errors) {
    if (errors.length !== 0) {
        const [{ message }] = errors;
        throw new SyntaxError(message.replace(/^Parser Error: | at column \d+ in [^]*$/g, ''));
    }
}
function extractComments(input, ngParser) {
    // @ts-ignore
    const commentStart = ngParser._commentStart(input);
    return commentStart === null
        ? { astInput: input, comments: [] }
        : {
            astInput: input.slice(0, commentStart),
            comments: [
                {
                    type: 'Comment',
                    value: input.slice(commentStart + '//'.length),
                    span: { start: commentStart, end: input.length },
                },
            ],
        };
}
// prettier-ignore
function getNgType(node) {
    if (node instanceof ng.Binary) {
        return 'Binary';
    }
    if (node instanceof ng.BindingPipe) {
        return "BindingPipe";
    }
    if (node instanceof ng.Chain) {
        return "Chain";
    }
    if (node instanceof ng.Conditional) {
        return "Conditional";
    }
    if (node instanceof ng.EmptyExpr) {
        return "EmptyExpr";
    }
    if (node instanceof ng.FunctionCall) {
        return "FunctionCall";
    }
    if (node instanceof ng.ImplicitReceiver) {
        return "ImplicitReceiver";
    }
    if (node instanceof ng.KeyedRead) {
        return "KeyedRead";
    }
    if (node instanceof ng.KeyedWrite) {
        return "KeyedWrite";
    }
    if (node instanceof ng.LiteralArray) {
        return "LiteralArray";
    }
    if (node instanceof ng.LiteralMap) {
        return "LiteralMap";
    }
    if (node instanceof ng.LiteralPrimitive) {
        return "LiteralPrimitive";
    }
    if (node instanceof ng.MethodCall) {
        return "MethodCall";
    }
    if (node instanceof ng.NonNullAssert) {
        return "NonNullAssert";
    }
    if (node instanceof ng.PrefixNot) {
        return "PrefixNot";
    }
    if (node instanceof ng.PropertyRead) {
        return "PropertyRead";
    }
    if (node instanceof ng.PropertyWrite) {
        return "PropertyWrite";
    }
    if (node instanceof ng.Quote) {
        return "Quote";
    }
    if (node instanceof ng.SafeMethodCall) {
        return "SafeMethodCall";
    }
    if (node instanceof ng.SafePropertyRead) {
        return "SafePropertyRead";
    }
    return node.type;
}
exports.getNgType = getNgType;
function stripSurroundingSpaces({ start: startIndex, end: endIndex }, text) {
    let start = startIndex;
    let end = endIndex;
    while (end !== start && /\s/.test(text[end - 1])) {
        end--;
    }
    while (start !== end && /\s/.test(text[start])) {
        start++;
    }
    return { start, end };
}
function expandSurroundingSpaces({ start: startIndex, end: endIndex }, text) {
    let start = startIndex;
    let end = endIndex;
    while (end !== text.length && /\s/.test(text[end])) {
        end++;
    }
    while (start !== 0 && /\s/.test(text[start - 1])) {
        start--;
    }
    return { start, end };
}
function expandSurroundingParens(span, text) {
    return text[span.start - 1] === '(' && text[span.end] === ')'
        ? { start: span.start - 1, end: span.end + 1 }
        : span;
}
function fitSpans(span, text, hasParentParens) {
    let parensCount = 0;
    const outerSpan = { start: span.start, end: span.end };
    while (true) {
        const spacesExpandedSpan = expandSurroundingSpaces(outerSpan, text);
        const parensExpandedSpan = expandSurroundingParens(spacesExpandedSpan, text);
        if (spacesExpandedSpan.start === parensExpandedSpan.start &&
            spacesExpandedSpan.end === parensExpandedSpan.end) {
            break;
        }
        outerSpan.start = parensExpandedSpan.start;
        outerSpan.end = parensExpandedSpan.end;
        parensCount++;
    }
    return {
        hasParens: (hasParentParens ? parensCount - 1 : parensCount) !== 0,
        outerSpan: stripSurroundingSpaces(hasParentParens
            ? { start: outerSpan.start + 1, end: outerSpan.end - 1 }
            : outerSpan, text),
        innerSpan: stripSurroundingSpaces(span, text),
    };
}
exports.fitSpans = fitSpans;
function findFrontChar(regex, index, text) {
    let i = index;
    while (!regex.test(text[i])) {
        i--;
    }
    return i;
}
exports.findFrontChar = findFrontChar;
function findBackChar(regex, index, text) {
    let i = index;
    while (!regex.test(text[i])) {
        i++;
    }
    return i;
}
exports.findBackChar = findBackChar;
function toLowerCamelCase(str) {
    return str.slice(0, 1).toLowerCase() + str.slice(1);
}
exports.toLowerCamelCase = toLowerCamelCase;
function getLast(array) {
    return array.length === 0
        ? // istanbul ignore next
            undefined
        : array[array.length - 1];
}
exports.getLast = getLast;
