"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const transform_1 = require("./transform");
const utils_1 = require("./utils");
function transformTemplateBindings(rawTemplateBindings, context) {
    const [firstTemplateBinding] = rawTemplateBindings;
    const { key: prefix } = firstTemplateBinding;
    const templateBindings = context.text
        .slice(firstTemplateBinding.span.start, firstTemplateBinding.span.end)
        .trim().length === 0
        ? rawTemplateBindings.slice(1)
        : rawTemplateBindings;
    const body = [];
    let lastTemplateBinding = null;
    for (let i = 0; i < templateBindings.length; i++) {
        const templateBinding = templateBindings[i];
        const { key, keyIsVar, name, span } = templateBinding;
        if (lastTemplateBinding &&
            lastTemplateBinding.key === name &&
            keyIsVar &&
            /^as\s$/.test(context.text.slice(span.start, span.start + 3))) {
            const keyStart = utils_1.findBackChar(/\S/, span.start + 3, context.text);
            const keySpan = findBackKeySpan(keyStart, key);
            const alias = _c('NGMicrosyntaxKey', { name: key }, keySpan);
            const updateSpanEnd = (node, end) => (Object.assign(Object.assign({}, node), transform_1.transformSpan({ start: node.start, end }, context)));
            const updateExpressionAlias = (expression) => (Object.assign(Object.assign({}, updateSpanEnd(expression, alias.end)), { alias }));
            const lastNode = body.pop();
            // istanbul ignore else
            if (lastNode.type === 'NGMicrosyntaxExpression') {
                body.push(updateExpressionAlias(lastNode));
            }
            else if (lastNode.type === 'NGMicrosyntaxKeyedExpression') {
                const expression = updateExpressionAlias(lastNode.expression);
                body.push(updateSpanEnd(Object.assign(Object.assign({}, lastNode), { expression }), expression.end));
            }
            else {
                throw new Error(`Unexpected type ${lastNode.type}`);
            }
        }
        else {
            body.push(transformTemplateBinding(templateBinding, i));
        }
        lastTemplateBinding = templateBinding;
    }
    return _c('NGMicrosyntax', { body }, body.length === 0
        ? rawTemplateBindings[0].span
        : { start: body[0].start, end: body[body.length - 1].end });
    function transformTemplateBinding({ key, keyIsVar, name, expression, span }, index) {
        if (!keyIsVar) {
            if (!expression) {
                return _c('NGMicrosyntaxKey', { name: removePrefix(key) }, span);
            }
            else if (index === 0) {
                return _c('NGMicrosyntaxExpression', { expression: _t(expression.ast), alias: null }, span);
            }
            else {
                const ngExpression = _t(expression.ast);
                const { start, end } = ngExpression;
                const keyName = removePrefix(key);
                return _c('NGMicrosyntaxKeyedExpression', {
                    key: _c('NGMicrosyntaxKey', { name: keyName }, findBackKeySpan(span.start, keyName)),
                    expression: _c('NGMicrosyntaxExpression', { expression: ngExpression, alias: null }, { start, end }),
                }, span);
            }
        }
        else {
            if (/^let\s$/.test(context.text.slice(span.start, span.start + 4))) {
                const keyStart = utils_1.findBackChar(/\S/, span.start + 4, context.text);
                const keySpan = findBackKeySpan(keyStart, key);
                return _c('NGMicrosyntaxLet', {
                    key: _c('NGMicrosyntaxKey', { name: key }, keySpan),
                    value: context.text.slice(keySpan.end, span.end).trim().length === 0
                        ? null
                        : _c('NGMicrosyntaxKey', { name }, {
                            start: utils_1.findBackChar(/=/, keySpan.end, context.text) + 1,
                            end: span.end,
                        }),
                }, span);
            }
            else {
                const keySpan = findBackKeySpan(span.start, name);
                return _c('NGMicrosyntaxAs', {
                    key: _c('NGMicrosyntaxKey', { name }, keySpan),
                    alias: _c('NGMicrosyntaxKey', { name: key }, {
                        start: utils_1.findBackChar(/\S/, keySpan.end, context.text) + 'as'.length,
                        end: span.end,
                    }),
                }, span);
            }
        }
    }
    function _t(n) {
        return transform_1.transform(n, context);
    }
    function _c(t, n, span, stripSpaces = true) {
        return Object.assign(Object.assign({ type: t }, transform_1.transformSpan(span, context, stripSpaces)), n);
    }
    function findBackKeySpan(start, key) {
        if (context.text[start] !== "'" && context.text[start] !== '"') {
            return { start, end: start + key.length };
        }
        const quote = context.text[start];
        let backslash = 0;
        let index = start + 1;
        while (true) {
            const char = context.text[index];
            if (char === quote && backslash % 2 === 0) {
                return { start, end: index + 1 };
            }
            if (char === '\\') {
                backslash++;
            }
            else {
                backslash = 0;
            }
            index++;
        }
    }
    function removePrefix(string) {
        return utils_1.toLowerCamelCase(string.slice(prefix.length));
    }
}
exports.transformTemplateBindings = transformTemplateBindings;
