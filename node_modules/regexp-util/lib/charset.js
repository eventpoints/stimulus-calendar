"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var base_1 = require("./base");
var Charset = /** @class */ (function (_super) {
    tslib_1.__extends(Charset, _super);
    function Charset() {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.data = [];
        for (var _a = 0, inputs_1 = inputs; _a < inputs_1.length; _a++) {
            var input = inputs_1[_a];
            if (input instanceof Charset) {
                (_b = _this.data).push.apply(_b, input.data);
            }
            else {
                _this.data.push(normalize(input));
            }
        }
        _this._unique();
        return _this;
        var _b;
    }
    Charset.prototype.union = function () {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        return new (Charset.bind.apply(Charset, [void 0, this].concat(inputs)))();
    };
    Charset.prototype.subtract = function () {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        var current_data = this.data.slice();
        var new_data = [];
        var subtract_index = 0;
        var subtract_data = new (Charset.bind.apply(Charset, [void 0].concat(inputs)))().data;
        while (current_data.length !== 0) {
            var data_unit = current_data.shift();
            var start = data_unit[0], end = data_unit[1];
            var is_done = void 0;
            do {
                is_done = true;
                var subtract_data_unit = subtract_data[subtract_index];
                if (subtract_data_unit === undefined) {
                    new_data.push(data_unit);
                    break;
                }
                var subtract_start = subtract_data_unit[0], subtract_end = subtract_data_unit[1];
                if (subtract_end < start) {
                    // front + no overlap
                    is_done = false;
                    subtract_index++;
                }
                else if (end < subtract_start) {
                    // back + no overlap
                    new_data.push(data_unit);
                }
                else if (subtract_start <= start && subtract_end < end) {
                    // front overlap
                    subtract_index++;
                    current_data.unshift([subtract_end + 1, end]);
                }
                else if (start < subtract_start && subtract_end < end) {
                    // central overlap
                    subtract_index++;
                    new_data.push([start, subtract_start - 1]);
                    current_data.unshift([subtract_end + 1, end]);
                }
                else if (start < subtract_start && end <= subtract_end) {
                    // back overlap
                    new_data.push([start, subtract_start - 1]);
                } // else: entire overlap
            } while (!is_done);
        }
        return new (Charset.bind.apply(Charset, [void 0].concat(new_data)))();
    };
    Charset.prototype.intersect = function () {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        return this.subtract(this.subtract.apply(this, inputs));
    };
    Charset.prototype._is_empty = function () {
        return this.data.length === 0;
    };
    Charset.prototype._to_string = function () {
        return ranges_to_string(this.data);
    };
    Charset.prototype._unique = function () {
        this.data.sort(compare);
        var new_data = [];
        var last_data_unit = null;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var data_unit = _a[_i];
            if (last_data_unit === null || last_data_unit[1] + 1 < data_unit[0]) {
                new_data.push(data_unit);
                last_data_unit = data_unit;
            }
            else {
                new_data.splice(-1, 1, [
                    Math.min(data_unit[0], last_data_unit[0]),
                    Math.max(data_unit[1], last_data_unit[1]),
                ]);
                last_data_unit = new_data[new_data.length - 1];
            }
        }
        this.data = new_data;
    };
    return Charset;
}(base_1.Base));
exports.Charset = Charset;
exports.charset = function () {
    var inputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
    }
    return new (Charset.bind.apply(Charset, [void 0].concat(inputs)))();
};
function char_code(char) {
    if (char.length !== 1) {
        var display = char.length + " (" + JSON.stringify(char) + ")";
        throw new Error("Expected length = 1, but received " + display + ".");
    }
    return char.charCodeAt(0);
}
function normalize(raw_input) {
    if (typeof raw_input === 'number' &&
        (raw_input < 0 || raw_input > 0x10ffff)) {
        throw new Error("Invalid unicode code point detected: " + (raw_input < 0 ? raw_input : "0x" + raw_input.toString(16)));
    }
    var normalized = [raw_input]
        .map(function (x) { return (typeof x !== 'object' ? [x, x] : x); })
        .map(function (x) { return x.map(function (u) { return (typeof u === 'string' ? char_code(u) : u); }); })[0];
    return normalized;
}
function compare(a, b) {
    return a[0] - b[0];
}
function ranges_to_string(ranges) {
    var _a = split_ranges(ranges), normal = _a.normal, surrogate = _a.surrogate;
    var patterns = [];
    if (normal.length !== 0) {
        patterns.push(normal_to_pattern(normal));
    }
    patterns.push.apply(patterns, surrogate_to_patterns(surrogate));
    return patterns.join('|');
}
function normal_to_pattern(normal) {
    var ranges = normal.map(function (_a) {
        var start = _a[0], end = _a[1];
        return start === end ? unicode(start) : unicode(start) + "-" + unicode(end);
    });
    return "[" + ranges.join('') + "]";
}
function surrogate_to_patterns(surrogate) {
    var patterns = [];
    if (surrogate.entire.data.length !== 0) {
        var h = surrogate.entire.toString();
        var l = "[" + [56320 /* MinL */, 57343 /* MaxL */]
            .map(unicode)
            .join('-') + "]";
        patterns.push("" + h + l);
    }
    for (var _i = 0, _a = surrogate.partial; _i < _a.length; _i++) {
        var _b = _a[_i], raw_h = _b.h, l_charset = _b.l;
        var h = unicode(raw_h);
        var l = l_charset.toString();
        patterns.push("" + h + l);
    }
    return patterns;
}
function split_ranges(data) {
    var normal = [];
    var surrogate_ranges = [];
    for (var i = 0; i < data.length; i++) {
        var data_unit = data[i];
        var start = data_unit[0], end = data_unit[1];
        if (start >= 65536 /* Min */) {
            surrogate_ranges.push.apply(surrogate_ranges, data.slice(i));
            break;
        }
        if (end >= 65536 /* Min */) {
            normal.push([start, 65536 /* Min */ - 1]);
            surrogate_ranges.push.apply(surrogate_ranges, [[0x10000, end]].concat(data.slice(i + 1)));
            break;
        }
        normal.push(data_unit);
    }
    return { normal: normal, surrogate: split_surrogate_ranges(surrogate_ranges) };
}
function split_surrogate_ranges(ranges) {
    var entire = [];
    var partial = [];
    for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {
        var _a = ranges_1[_i], start = _a[0], end = _a[1];
        var start_pair = surrogate_pair(start);
        var end_pair = surrogate_pair(end);
        if (start_pair.h === end_pair.h) {
            add_partial_range(start_pair.h, start_pair.l, end_pair.l);
            continue;
        }
        if (start_pair.l === 56320 /* MinL */) {
            add_entire_range(start_pair.h);
        }
        else {
            add_partial_range(start_pair.h, start_pair.l, 57343 /* MaxL */);
        }
        for (var h = start_pair.h + 1; h < end_pair.h; h++) {
            add_entire_range(h);
        }
        if (end_pair.l === 57343 /* MaxL */) {
            add_entire_range(end_pair.h);
        }
        else {
            add_partial_range(end_pair.h, 56320 /* MinL */, end_pair.l);
        }
    }
    return {
        entire: new (Charset.bind.apply(Charset, [void 0].concat(entire)))(),
        partial: partial.map(function (_a) {
            var h = _a.h, l = _a.l;
            return ({ h: h, l: new (Charset.bind.apply(Charset, [void 0].concat(l)))() });
        }),
    };
    function add_entire_range(h) {
        entire.push(h);
    }
    function add_partial_range(h, start, end) {
        var last_partial = partial[partial.length - 1];
        if (last_partial !== undefined && last_partial.h === h) {
            last_partial.l.push([start, end]);
        }
        else {
            partial.push({ h: h, l: [[start, end]] });
        }
    }
}
// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
function surrogate_pair(codepoint) {
    return {
        h: Math.floor((codepoint - 0x10000) / 0x400) + 0xd800,
        l: (codepoint - 0x10000) % 0x400 + 0xdc00,
    };
}
function unicode(char) {
    var hex = char.toString(16);
    return "\\u" + '0'.repeat(4 - hex.length) + hex;
}
