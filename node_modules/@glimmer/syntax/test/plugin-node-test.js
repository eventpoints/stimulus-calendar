'use strict';

var _syntax = require('@glimmer/syntax');

var _util = require('../../util');

const { test } = QUnit;
QUnit.module('[glimmer-syntax] Plugins - AST Transforms');
test('function based AST plugins can be provided to the compiler', assert => {
    assert.expect(1);
    (0, _syntax.preprocess)('<div></div>', {
        plugins: {
            ast: [() => ({
                name: 'plugin-a',
                visitor: {
                    Program() {
                        assert.ok(true, 'transform was called!');
                    }
                }
            })]
        }
    });
});
test('plugins are provided the syntax package', assert => {
    assert.expect(1);
    (0, _syntax.preprocess)('<div></div>', {
        plugins: {
            ast: [({ syntax }) => {
                assert.equal(syntax.Walker, _syntax.Walker);
                return { name: 'plugin-a', visitor: {} };
            }]
        }
    });
});
test('can support the legacy AST transform API via ASTPlugin', assert => {
    function ensurePlugin(FunctionOrPlugin) {
        if (FunctionOrPlugin.prototype && FunctionOrPlugin.prototype.transform) {
            return env => {
                return {
                    name: 'plugin-a',
                    visitor: {
                        Program(node) {
                            let plugin = new FunctionOrPlugin(env);
                            plugin.syntax = env.syntax;
                            return plugin.transform(node);
                        }
                    }
                };
            };
        } else {
            return FunctionOrPlugin;
        }
    }
    class Plugin {
        transform(program) {
            assert.ok(true, 'transform was called!');
            return program;
        }
    }
    (0, _syntax.preprocess)('<div></div>', {
        plugins: {
            ast: [ensurePlugin(Plugin)]
        }
    });
});
const FIRST_PLUGIN = new WeakMap();
const SECOND_PLUGIN = new WeakMap();
const THIRD_PLUGIN = new WeakMap();
test('AST plugins can be chained', assert => {
    assert.expect(3);
    let first = () => {
        return {
            name: 'first',
            visitor: {
                Program(program) {
                    FIRST_PLUGIN.set(program, true);
                }
            }
        };
    };
    let second = () => {
        return {
            name: 'second',
            visitor: {
                Program(node) {
                    assert.equal(FIRST_PLUGIN.get(node), true, 'AST from first plugin is passed to second');
                    SECOND_PLUGIN.set(node, true);
                }
            }
        };
    };
    let third = () => {
        return {
            name: 'third',
            visitor: {
                Program(node) {
                    assert.equal(SECOND_PLUGIN.get(node), true, 'AST from second plugin is passed to third');
                    THIRD_PLUGIN.set(node, true);
                }
            }
        };
    };
    let ast = (0, _syntax.preprocess)('<div></div>', {
        plugins: {
            ast: [first, second, third]
        }
    });
    assert.equal(THIRD_PLUGIN.get(ast), true, 'return value from last AST transform is used');
});
test('AST plugins can access meta from environment', assert => {
    assert.expect(2);
    const locator = {
        module: 'template/module/name',
        name: 'default'
    };
    let hasExposedEnvMeta = env => {
        return {
            name: 'exposedMetaTemplateData',
            visitor: {
                Program() {
                    const { meta } = env;
                    const { module, name } = (0, _util.expect)(meta, 'expected meta to not be null');
                    assert.equal(module, 'template/module/name', 'module was passed in the meta enviornment property');
                    assert.equal(name, 'default', 'name was passed in the meta enviornment property');
                }
            }
        };
    };
    (0, _syntax.preprocess)('<div></div>', {
        meta: locator,
        plugins: {
            ast: [hasExposedEnvMeta]
        }
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC90ZXN0L3BsdWdpbi1ub2RlLXRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQVNBOztBQUVBLE1BQU0sRUFBRSxJQUFGLEtBQVcsS0FBakI7QUFFQSxNQUFNLE1BQU4sQ0FBYSwyQ0FBYjtBQUVBLEtBQUssNERBQUwsRUFBbUUsVUFBUztBQUMxRSxXQUFPLE1BQVAsQ0FBYyxDQUFkO0FBRUEsNEJBQVcsYUFBWCxFQUEwQjtBQUN4QixpQkFBUztBQUNQLGlCQUFLLENBQ0gsT0FBTztBQUNMLHNCQUFNLFVBREQ7QUFFTCx5QkFBUztBQUNQLDhCQUFPO0FBQ0wsK0JBQU8sRUFBUCxDQUFVLElBQVYsRUFBZ0IsdUJBQWhCO0FBQ0Q7QUFITTtBQUZKLGFBQVAsQ0FERztBQURFO0FBRGUsS0FBMUI7QUFjRCxDQWpCRDtBQW1CQSxLQUFLLHlDQUFMLEVBQWdELFVBQVM7QUFDdkQsV0FBTyxNQUFQLENBQWMsQ0FBZDtBQUVBLDRCQUFXLGFBQVgsRUFBMEI7QUFDeEIsaUJBQVM7QUFDUCxpQkFBSyxDQUNILENBQUMsRUFBRSxNQUFGLEVBQUQsS0FBZTtBQUNiLHVCQUFPLEtBQVAsQ0FBYSxPQUFPLE1BQXBCLEVBQTRCLGNBQTVCO0FBRUEsdUJBQU8sRUFBRSxNQUFNLFVBQVIsRUFBb0IsU0FBUyxFQUE3QixFQUFQO0FBQ0QsYUFMRTtBQURFO0FBRGUsS0FBMUI7QUFXRCxDQWREO0FBZ0JBLEtBQUssd0RBQUwsRUFBK0QsVUFBUztBQUN0RSxhQUFTLFlBQVQsQ0FBc0IsZ0JBQXRCLEVBQTJDO0FBQ3pDLFlBQUksaUJBQWlCLFNBQWpCLElBQThCLGlCQUFpQixTQUFqQixDQUEyQixTQUE3RCxFQUF3RTtBQUN0RSxtQkFBUSxHQUFELElBQThCO0FBQ25DLHVCQUFPO0FBQ0wsMEJBQU0sVUFERDtBQUdMLDZCQUFTO0FBQ1AsZ0NBQVEsSUFBUixFQUF5QjtBQUN2QixnQ0FBSSxTQUFTLElB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QUQ7QUFERTtBQUZlLEtBQTFCO0FBTUQsQ0FoQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBwcmVwcm9jZXNzLFxuICBTeW50YXgsXG4gIFdhbGtlcixcbiAgQVNULFxuICBBU1RQbHVnaW5FbnZpcm9ubWVudCxcbiAgQVNUUGx1Z2luQnVpbGRlcixcbn0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IE1vZHVsZUxvY2F0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGV4cGVjdCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5jb25zdCB7IHRlc3QgfSA9IFFVbml0O1xuXG5RVW5pdC5tb2R1bGUoJ1tnbGltbWVyLXN5bnRheF0gUGx1Z2lucyAtIEFTVCBUcmFuc2Zvcm1zJyk7XG5cbnRlc3QoJ2Z1bmN0aW9uIGJhc2VkIEFTVCBwbHVnaW5zIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgY29tcGlsZXInLCBhc3NlcnQgPT4ge1xuICBhc3NlcnQuZXhwZWN0KDEpO1xuXG4gIHByZXByb2Nlc3MoJzxkaXY+PC9kaXY+Jywge1xuICAgIHBsdWdpbnM6IHtcbiAgICAgIGFzdDogW1xuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgIG5hbWU6ICdwbHVnaW4tYScsXG4gICAgICAgICAgdmlzaXRvcjoge1xuICAgICAgICAgICAgUHJvZ3JhbSgpIHtcbiAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHRydWUsICd0cmFuc2Zvcm0gd2FzIGNhbGxlZCEnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICBdLFxuICAgIH0sXG4gIH0pO1xufSk7XG5cbnRlc3QoJ3BsdWdpbnMgYXJlIHByb3ZpZGVkIHRoZSBzeW50YXggcGFja2FnZScsIGFzc2VydCA9PiB7XG4gIGFzc2VydC5leHBlY3QoMSk7XG5cbiAgcHJlcHJvY2VzcygnPGRpdj48L2Rpdj4nLCB7XG4gICAgcGx1Z2luczoge1xuICAgICAgYXN0OiBbXG4gICAgICAgICh7IHN5bnRheCB9KSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKHN5bnRheC5XYWxrZXIsIFdhbGtlcik7XG5cbiAgICAgICAgICByZXR1cm4geyBuYW1lOiAncGx1Z2luLWEnLCB2aXNpdG9yOiB7fSB9O1xuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICB9KTtcbn0pO1xuXG50ZXN0KCdjYW4gc3VwcG9ydCB0aGUgbGVnYWN5IEFTVCB0cmFuc2Zvcm0gQVBJIHZpYSBBU1RQbHVnaW4nLCBhc3NlcnQgPT4ge1xuICBmdW5jdGlvbiBlbnN1cmVQbHVnaW4oRnVuY3Rpb25PclBsdWdpbjogYW55KTogQVNUUGx1Z2luQnVpbGRlciB7XG4gICAgaWYgKEZ1bmN0aW9uT3JQbHVnaW4ucHJvdG90eXBlICYmIEZ1bmN0aW9uT3JQbHVnaW4ucHJvdG90eXBlLnRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIChlbnY6IEFTVFBsdWdpbkVudmlyb25tZW50KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogJ3BsdWdpbi1hJyxcblxuICAgICAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgICAgIFByb2dyYW0obm9kZTogQVNULlByb2dyYW0pIHtcbiAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IG5ldyBGdW5jdGlvbk9yUGx1Z2luKGVudik7XG5cbiAgICAgICAgICAgICAgcGx1Z2luLnN5bnRheCA9IGVudi5zeW50YXg7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbi50cmFuc2Zvcm0obm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb25PclBsdWdpbjtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBQbHVnaW4ge1xuICAgIHN5bnRheCE6IFN5bnRheDtcblxuICAgIHRyYW5zZm9ybShwcm9ncmFtOiBBU1QuUHJvZ3JhbSk6IEFTVC5Qcm9ncmFtIHtcbiAgICAgIGFzc2VydC5vayh0cnVlLCAndHJhbnNmb3JtIHdhcyBjYWxsZWQhJyk7XG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH1cblxuICBwcmVwcm9jZXNzKCc8ZGl2PjwvZGl2PicsIHtcbiAgICBwbHVnaW5zOiB7XG4gICAgICBhc3Q6IFtlbnN1cmVQbHVnaW4oUGx1Z2luKV0sXG4gICAgfSxcbiAgfSk7XG59KTtcblxuY29uc3QgRklSU1RfUExVR0lOID0gbmV3IFdlYWtNYXA8QVNULlByb2dyYW0gfCBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGUsIGJvb2xlYW4+KCk7XG5jb25zdCBTRUNPTkRfUExVR0lOID0gbmV3IFdlYWtNYXA8QVNULlByb2dyYW0gfCBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGUsIGJvb2xlYW4+KCk7XG5jb25zdCBUSElSRF9QTFVHSU4gPSBuZXcgV2Vha01hcDxBU1QuUHJvZ3JhbSB8IEFTVC5CbG9jayB8IEFTVC5UZW1wbGF0ZSwgYm9vbGVhbj4oKTtcblxudGVzdCgnQVNUIHBsdWdpbnMgY2FuIGJlIGNoYWluZWQnLCBhc3NlcnQgPT4ge1xuICBhc3NlcnQuZXhwZWN0KDMpO1xuXG4gIGxldCBmaXJzdCA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ2ZpcnN0JyxcbiAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgUHJvZ3JhbShwcm9ncmFtOiBBU1QuUHJvZ3JhbSB8IEFTVC5UZW1wbGF0ZSB8IEFTVC5CbG9jaykge1xuICAgICAgICAgIEZJUlNUX1BMVUdJTi5zZXQocHJvZ3JhbSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbiAgbGV0IHNlY29uZCA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ3NlY29uZCcsXG4gICAgICB2aXNpdG9yOiB7XG4gICAgICAgIFByb2dyYW0obm9kZTogQVNULlByb2dyYW0gfCBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGUpIHtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoRklSU1RfUExVR0lOLmdldChub2RlKSwgdHJ1ZSwgJ0FTVCBmcm9tIGZpcnN0IHBsdWdpbiBpcyBwYXNzZWQgdG8gc2Vjb25kJyk7XG5cbiAgICAgICAgICBTRUNPTkRfUExVR0lOLnNldChub2RlLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICBsZXQgdGhpcmQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICd0aGlyZCcsXG4gICAgICB2aXNpdG9yOiB7XG4gICAgICAgIFByb2dyYW0obm9kZTogQVNULlByb2dyYW0gfCBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGUpIHtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoU0VDT05EX1BMVUdJTi5nZXQobm9kZSksIHRydWUsICdBU1QgZnJvbSBzZWNvbmQgcGx1Z2luIGlzIHBhc3NlZCB0byB0aGlyZCcpO1xuXG4gICAgICAgICAgVEhJUkRfUExVR0lOLnNldChub2RlLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICBsZXQgYXN0ID0gcHJlcHJvY2VzcygnPGRpdj48L2Rpdj4nLCB7XG4gICAgcGx1Z2luczoge1xuICAgICAgYXN0OiBbZmlyc3QsIHNlY29uZCwgdGhpcmRdLFxuICAgIH0sXG4gIH0pO1xuXG4gIGFzc2VydC5lcXVhbChUSElSRF9QTFVHSU4uZ2V0KGFzdCksIHRydWUsICdyZXR1cm4gdmFsdWUgZnJvbSBsYXN0IEFTVCB0cmFuc2Zvcm0gaXMgdXNlZCcpO1xufSk7XG5cbnRlc3QoJ0FTVCBwbHVnaW5zIGNhbiBhY2Nlc3MgbWV0YSBmcm9tIGVudmlyb25tZW50JywgYXNzZXJ0ID0+IHtcbiAgYXNzZXJ0LmV4cGVjdCgyKTtcblxuICBjb25zdCBsb2NhdG9yOiBNb2R1bGVMb2NhdG9yID0ge1xuICAgIG1vZHVsZTogJ3RlbXBsYXRlL21vZHVsZS9uYW1lJyxcbiAgICBuYW1lOiAnZGVmYXVsdCcsXG4gIH07XG5cbiAgbGV0IGhhc0V4cG9zZWRFbnZNZXRhID0gKGVudjogQVNUUGx1Z2luRW52aXJvbm1lbnQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ2V4cG9zZWRNZXRhVGVtcGxhdGVEYXRhJyxcbiAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgUHJvZ3JhbSgpIHtcbiAgICAgICAgICBjb25zdCB7IG1ldGEgfSA9IGVudjtcbiAgICAgICAgICBjb25zdCB7IG1vZHVsZSwgbmFtZSB9ID0gZXhwZWN0KG1ldGEgYXMgTW9kdWxlTG9jYXRvciwgJ2V4cGVjdGVkIG1ldGEgdG8gbm90IGJlIG51bGwnKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICAndGVtcGxhdGUvbW9kdWxlL25hbWUnLFxuICAgICAgICAgICAgJ21vZHVsZSB3YXMgcGFzc2VkIGluIHRoZSBtZXRhIGVudmlvcm5tZW50IHByb3BlcnR5J1xuICAgICAgICAgICk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKG5hbWUsICdkZWZhdWx0JywgJ25hbWUgd2FzIHBhc3NlZCBpbiB0aGUgbWV0YSBlbnZpb3JubWVudCBwcm9wZXJ0eScpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIHByZXByb2Nlc3MoJzxkaXY+PC9kaXY+Jywge1xuICAgIG1ldGE6IGxvY2F0b3IsXG4gICAgcGx1Z2luczoge1xuICAgICAgYXN0OiBbaGFzRXhwb3NlZEVudk1ldGFdLFxuICAgIH0sXG4gIH0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9